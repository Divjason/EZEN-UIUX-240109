*상태 = state 관리 :
- useState( )
- component상에 변화 및 업데이트가 필요한 요소가 존재 => 관리
- 하나의 컴포넌트안에 관리해야할 상태가 많아지면 어떤 문제?
- 컴포넌트 state 업데이트가 되면, 리렌더링
- 리액트를 사용하는 이유?
> 컴포넌트 & 가상돔 => CSR => SSR UI 화면 출력 매우 빠르고, 효율적이다!!

*상태관리의 효율성!!!
*useState
*useRef
*useEffect
*useReducer
=> useReducer 리액트 훅!!!
=> reducer JS함수 : 누산기
=> 차곡차곡 쌓아서 어떤 작업을 실행하는 개념

*useState( ) : 컴포넌트 바깥에서 실행해본 적 없음!!
=> 1번만 실행되고, => 무한반복!!!
=> setCount함수 컴포넌트 바깥으로 나가게 되면
컴포넌트가 리랜더링 되는 순간 count값을 최초의 초기값으로 reset!!!

*최적화

*데이터 효율성


* : 전체선택자
=> wildcard selector


React.js 최적화 3가지 방법
1) 리액트 훅 : useMemo
- 메모이제이션
*메모이제이션을 하고자 하는 함수를 콜백함수로 사용, 두번째 매개변수로 의존성 배열
- 불필요한 함수 재호출 방지를 하고자 할 때

2) React.memo(리렌더링을 방지하고자하는 컴포넌트)
- 불필요한 컴포넌트 리렌더링을 방지하고자 할 때

*컴포넌트가 렌더링 3대 포인트
- state 상태 값이 변화
- props 값 변화
- 부모컴포넌트 렌더링 => 자식 렌더링

*JS 초기 학습
- 원시타입 자료
(*문자열, 숫자, 불리언)

- 참조타입 자료
(*객체기반 자료 => 객체, 배열, 함수)
(*함수 => 
class / constructure => 프로토타입 객체 => 인스턴스 객체 (*부모 프로토타입 설정, 객체 키 & 메서드)
함수 => 객체기반 자료!!!
변수 = 원본 객체 / 2변수 = 복사 / 수정!!

3) React.memo( ) / useCallback( ) 
useCallback(콜백함수, 의존성배열)
useEffect(콜백함수, 의존성배열)

*최적화!!!
1) 작업중인 모든 컴포넌트와 함수를 다 최적화!!! => 불가 / 쓸데없는 짓!!!
(*반드시 꼭 필요하다고 생각하는 요소 최적화!!!)

2) 최적화는 반드시 컴포넌트의 작업이 어느정도 완료가 되는 시점에서만 해야함!!!
- 기능구현 > 최적화
- 최적화 > 기능구현
- 기능구현 & 최적화 

3) 최적화는 정답이 없음!!!
- 최적화 방법 3대장

*데이터 효율!!!

Props Drilling 문제

Context : 책 => 목차 => 맥락

Context를 활용한 API => Canvas / localstorage

데이터를 공급하는 root 컴포넌트에서는
React.createContext() 활용해서 객체 컴포넌트를 생성
생성된 객체 컴포넌트에서 .Provider라는 속성을 사용해야지만
데이터를 공급할 수 있는 환경설정 가능!!!

이때, root 컴포넌트에서 공급받은 데이터 중 자식 및 손자 컴포넌트에서 전달하고자 하는 데이터는 value라는 key를 활용해서 정의하면 됨!!!!

이제, 데이터를 공급받아야하는 컴포넌트에서 준비!!
react 라이브러리에서 useContext 훅을 찾아와서
해당 훅 함수의 반환값을 특정 변수에 할당!!!
(*이때, 해당 훅 함수의 매개변수는 부모요소에서 정의했던 Context API 컴포넌트로 적용!!!)

리팩토링!!!
=> JS 함수기능 => 요소
=> 1개의 함수안에 너무 많은 기능 포함
=> 버그 발생 리스크


1.useReducer
- 실습예시 : App.js 내 TestComp.js 삽입
- 사용이유 : 상태 변화 코드를 컴포넌트에서 분리
(*하나의 컴포넌트 안에 너무 많은 상태 변화 코드 불필요)
(*UI 구현 시, 비효율적 + 코드 버그 발생 리스크 높음)
- 장점 : 컴포넌트 외부에서 사용할 수 있음

2.최적화
- 메모이제이션 : 메모하는 방법 / 식당 예시
- 사용이유 :
1) 불필요한 함수 재호출 방지
(*컴포넌트 내부 선언함수 => 렌더링 할 때마다 실행 문제)
=> 대안 : useMemo

2) 불필요한 컴포넌트 리렌더링 방지
(*인수로 전달한 컴포넌트를 메모이제이션된 컴포넌트로 만들어 반환)
=> 대안 : React.memo
(*props가 변경되지 않는다면 리렌더링 안되도록 해줌)
(*함수도 참조타입 변수 / 객체를 통해서 생성됨)

3) React.memo를 보완하기 위해서 useCallback 필요

3.Props Drilling 문제 해결
1) useContext











