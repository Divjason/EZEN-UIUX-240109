React.js : JS 라이브러리
MealKit : Figma HTML, CSS, JS(*2~3개)

TS / TS + React.js

F/E : TS 필수!!!!

https://2022.stateofjs.com/en-US
https://programmers.co.kr/pages/2023-dev-survey

모든 프로그래밍 언어는 거의 대부분 타입 시스템!!!
전공자 / 백엔드!!!

Java를 포함 C언어 등의 언어들은 변수를 선언할 때, 사전에 변수안에 담겨야할 값의 타입을 정의!!!

한 번 정의된 타입은 계속 고정되어서 갑니다.
사용자에게 어떤 숫자를 받는다
숫자가 로컬스토리지에 갔다가 다시 웹브라우저
해당 값을 찾아오는 순간 자료 형 변환
Number( ) = Number( ) : x

JS : 단순히 웹브라우저에서 인터랙티브한 기능 구현
Node.js : JS 서버구현 : 막대한 돈이 투입될 수 있는 프로젝트를 구현 => JS

2012년 : C언어 개발
2016년 : 국내 2018년

TS : JS의 타입을 사전 지정할 수 있도록 도와주는 슈퍼셋 (*Super Set) 언어

TS는 어디에서 구현할 수 있으며, 어떻게 사용하는가?
=> 웹 브라우저는 HTML, CSS, JS
=> SCSS 컴파일러
=> 컴파일링 : Node에서 실행!!!

npm i ,,,
Node : npx create-react-app

node를 시작하거임!!!
npm init -y

TS : JS안에 있는 명령어 / 변수 / 값 : 타입
Node : TS

npm i @types/node

TS 코드를 입력 => 웹

npm i typescript -g
TS를 JS로 컴파일링 해주는 npm 앱

tsc -v

tsc src/index.ts

node src/index.js

*타입스크립트의 파일을 컴파일링함과 동시에 node로 실행까지 한 번에 시켜줄 수 있는 앱!!

npm i ts-node
npm i ts-node -g

ts-node src/index.ts

Compliing Option
: 상황에 따라서 어떤 경우 A 컴파일링 / B 컴파일링

tsc --init

ts파일 => 컴파일링 /
완료된 JS 버전 결정하는 옵션 target

화살표!!!
화살표함수 =>ES6

타입스크립트 & 리액트 => .d

ES

모듈!!!
Node.js => JS 모듈 정식 표준 설정/생성x
CommonJS

> import = require / export = exports.객체

CommonJS VS ESM

npm i tsx -g

tsx src/index.ts

2명의 개발자 넷플릭스
> 1 CJS 2 ESM

TS & React

1.TS를 사용해야하는 이유
2.TS를 세팅하는 방법
3.TS Compiler Option 세팅하는 방법


1.TS 주석
- JS 타입 종류 : 
1) 원시타입 : number, string, boolean, null, undefined
2) 참조타입 : object, array, function

2.TS 추론
- 굳이 꼭 주석을 달지 않아도 됨
(*하지만, 특별한 케이스)

3.TS 치트키 (*any타입)

4.TS
- JS VS => undefined / null : value
- undefined / null : 타입

5.TS 타입의 분류
- Super Type : 받을 수 있는 값이 많아짐
- Sub Type : 받을 수 있는 값이 적어짐

6.TS 객체 타입정의
- object => 객체계의 any임!!! (*객체계의 치트키임)
- interface => 객체 안에 들어가있는 각각의 key & value 타입 정의
- optional property => 선택속성 (*객체안에 있어도 되고, 없어도 되는 값에 대한 타입을 정의하고자 할 때) 
- 익명 interface => 이름을 부여하지 않은 interface

7.Class 타입 정의하기
- 붕어빵틀 / 붕어빵
- 동일한 혹은 유사한 형태의 객체가 많이 필요한 상황에서 매번 해당 객체를 신규로 생성해야하는 그 불편함을 해소하기 위해서 Class
- new Class()

8.interface 응용
- interface : 객체의 세부 타입 정의
- class 선언 할 때 참고 활용
- class가 interface를 참고해서 객체를 구현할 때에는 implements
(*implements : 실행하다)
(*반드시 implement를 하기로한 인터페이스 객체를 구현!!)

9.추상클래스
- 추상화
- 추상 <-> 명쾌하지 않음
- 어떤 사물이나 개념에서 공통점을 찾아서 추출한 형이상학적인 개념

객체를 생성하는데 있어서 객체의 세부적인 값들이 완전히 똑같아야할 수도 있지만, 특정요소 몇가지만 다르고, 나머지 70~80%는 거의 동일한 구성형태를 띄고 있는 객체를 만들어야하는 상황이 나올 수 있음

10~20%의 차이점 때문에 매번 새롭게 class를 생성해야하는가?

10.TS 구조분해 할당
- React & TS
- Components : Redux
- TS

11.TS 타입단언
- 타입을 정의해줘야하는 요소 as 타입을 정의하고자 하는 요소

12.함수 타입
- 함수타입 : 매개변수 & 반환값의 타입 정의 중요!
- 반화값이 없는 함수 : void
- 타입 시그니처 : 함수자체에 타입정의하지 않고, 별도의 시그니처에 타입을 정의하는 방식
- 타입 별칭(type) : 객체로 치면, interface같은 기능
- 타입 가드 : 함수의 매개변수에 어떤 값이 들어올지 예측불가 => 결과값에 대한 오류를 최대한 방지하기 위한 준비사항

13.함수 표현식
- 표현식문 VS 실행문
- 다중 패러다임
- 고차함수 / 클로저

14.기타 함수기능
- 매개변수를 활용한 구조분해할당 타입정의
- 함수를 활용한 객체생성법
- class를 생성할 때, 내부 메서드함수에서 this 객체 사용

15.배열 / 튜플
- 자료구조에 대한 개념 이야기할 예정
(*같은 결과를 만들어내는 데, 선언형 방식(*하이레벨) VS 명령형 방식 = 함수형 방식(*로우레벨))

- 배열의 기본 타입 정의
- 배열 내 객체 아이템 존재 시, 타입정의방법 (feat. interface)
- 반복문 사용 시, 타입정의방법
1) for
2) for in
3) for of

- 제네릭 타입

- 전개연산자 사용 시, 배열타입정의

16.배열을 활용한 선언형 VS 명령형 코드구현방식 (feat. 자료구조에 대한 이해)
*정말 죄송함!!!!! 이게 파이널!!!!!

1) 명령형 : 로우레벨 : 우리가 그동안 배워왔던 방식 / 로우레벨
> 배열안에 있는 값을 찾아서 알아서 더해라!!! 기능을 갖고 있는 함수 및 반복문
> 초심자들에게는 명령형 코드를 입력하는 것이 편리함!!!
> 커스터마이징

2) 선언형 = 함수형 : 하이레벨 (*고급 코딩 방법) 
> 처음 접하게 되면, 오히려 어려움 / 번거로움
> 코드의 실행단계를 분리시켜놓았기 때문에 커스터마이징 가능
> 맞춤형 코드 작성.개발 가능
> 버그가 발생했을 때, 코드가 분리되어 있어서 디버깅이 편리함

17.배열 > map / reduce / filter

18.선언형 방식을 활용해서 기존 배열 객체의 메서드 함수를 사용하고자 할 때 유의사항!!!
> TS에서는 선언형 방식으로 언제든 원할 때마다 배열의 메서드 함수를 가져다가 사용x

> 선언형 방식의 코드 작성방법은 반드시 "순수함수"인 경우에만 사용이 가능!!!!
(불순함수 => 선언형으로 배열의 메서드함수를 자유자재로 사용 x)

*순수함수가 되기 위한 전제조건 필요!!!!
1) 함수실행문안에 입력문, 출력문이 존재하지 x
2) 함수실행문안에서 외부에서 전달받은 매개변수의 값을 변경시키면 안됨!!!
3) 함수실행문안에서 만들어진 결과값이 바로 반환이 되어야함
4) 함수실행문안에서 외부에서 생성된 전역변수를 절대로 사용하면 안됨
5) Promise같은 비동기 방식으로 작동하는 코드가 없어야 함

*세미코루틴 / 스레드
*코루틴 / CPU
*운영체제 
- 중첩배열 사용 시, 타입정의

19.튜플


