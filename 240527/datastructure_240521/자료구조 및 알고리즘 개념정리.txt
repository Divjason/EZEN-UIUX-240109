*자료구조 :
데이터가 어떤 구조로 저장되고
어떻게 사용되는지를 나타내는
일련의 과정 및 결과물
> 로또번호 추첨기 프로그램 개발
> 로또번호를 랜덤으로 생성
> 변수 담아

*알고리즘 :
어떤 문제를 해결하기 위한 최고 및 최선의 효율적인 방법(론)

> 로또번호 추첨기 프로그램 개발
> 로또번호를 랜덤으로 생성
> 변수 담아

*시간복잡도
- 어떠한 문제를 해결해나가는데 걸리는 소요시간
- 2사람이 동시에 반복문
(*for / for of / while)

*어떻게 계산?
arr = [1, 3, 5, 7]
=> 미션, 주어진 배열에서 5를 찾으세요!!!

1) 한 번에 직접 찾는방법
2) 반복문 : 1~7 순회하면서 찾는방법
3) 가장 안좋은 방법 : 1, 3, 7, ~ 5를 찾는 방법
(*배열의 길이수 만큼 시간이 걸리는 방법)

=> 가장 시간이 많이 걸리는 상황을 전제하에 시간복잡도를 계산!!

*시간 복잡도의 단위!!!

- 빅오메가 : 최선의 경우, 한 번에 찾을 때를 의미
- 빅세타 : 평균의 경우, 배열의 길이 중간 만큼 시간이 걸리는 것을 의미
- 빅오 : 최악의 경우, 배열의 길이만큼 시간이 걸리는 것을 의미

> 로또번호 추첨기 프로그램 개발
> 로또번호를 랜덤으로 생성
> 변수 담아

- 프로그래밍 영역에서는 시간이 가장 오래걸릴 것으로 판단되는 그 구간을 발췌해서 시간복잡도를 계산!!

- 자바스크립트를 잘한다는 말은 무슨이야기!!!
> 배열과 반복문을 내가 자유롭게 가지고 놀 수 있으면
> 모든 프로그래밍 언어는 다 저마다의 반복문
> 사람이 일일히 비효율적으로 작업해야하는 단순 반복적인 행위를 컴퓨터에게 맡김으로인해서 프로그래밍 효율성 극대화!!!

*이터러블 객체가 구현하는 실행시간!!!
> 자료구조 & 알고리즘
> 반복문

*그렇다면, 자료구조 & 알고리즘 반복문 잘쓰기 경연대회?
> 지금 반복문?
> 반복문을 사용하지 않고 효율적인 코드를 작성하려면?
- 연결리스트!!! 개념

*반복문 => 이터러블 객체 => 배열!!!

*JS : 유연 / 근본

*배열 : Java / C / Python
배열을 정의할 때, 사전에 배열안에 몇개의 아이템이 들어가게 할지 결정을 짓는다!!

단 한번도 JS 배열을 사용할 때, 10개!!

자바스크립트 배열은 살짝 예외적인 상황이나, 배열의 경우 불편!!! 사전에 데이터에 대한 개수를 결정 => 데이터를 추가하거나 삭제하거나 불편

배열 => 참조타입 (*주소참조)
값이 100, 1000 => 데이터를 찾아오는 것이 매우 효율적 = 데이터를 읽고 사용하는것이 매우 신속.정확

*내가 지금 프로그래밍 코드를 작성하는데 있어서 데이터를 주기적 & 반복으로 생성, 삭제하는 편집요소의 기능이 많이 사용!!! => x, 연결리스트

*만약, 데이터를 불러오거나 읽는 기능이 주된 기능의 프로그래밍 코드 작성 => 배열 지향!!!, 연결리스트 지양

*연결리스트 배열이 아님!!!
> 하지만, 배열과 유사한 기능 구현!!!
> 각각의 고유한 값을 독립적으로 생성해주고, 이들을 서로 연결시켜주는 자료구조 형태!!!

*연결리스트를 활용해서 구현할 수 있는 기능 및 연산작업을 하나씩!!!
> 추상자료형!!!

1) 연결리스트의 모든 데이터를 출력 기능 (*완)
> printAll( )

2) 연결리스트의 모든 데이터를 제거 기능 (*완)
> clear( )

3) 연결리스트 내 인덱스를 삽입 기능 (*완)
> insertAt(index, data)

4) 연결리스트 내 인덱스를 삭제 기능 (*완)
> deleteAt(index)

5) 연결리스트 내 인덱스를 읽는 기능 (*완)
> getNodeAt(index)

6) 연결리스트 내 인덱스를 마지막에 삽입하는 기능 (*완)
> insertLast(data)

7) 연결리스트 내 인덱스를 마지막에서 삭제하는 기능 (*완)
> deleteLast(data)

*연결리스트 => Stack & Call

*시간복잡도

*stack : 아주 단순한 규칙을 가지고 있는 기능
> 특징 : 먼저 들어간 데이터가 반드시 나중에 나오는 규칙
> 사전적정의 : 무언가 차곡차곡 쌓이다
> 설거지!!!! : 가장 먼저 뽕뽕으로 닦은 접시를 가장 밑에놓는다 => 그 다음 접시 + 접시 + 접시 => 가장 위에 있는 접시부터 하나씩 헹굼
> 엘리베이터!!!! : 먼저온사람이 엘리베이터 먼저 탑승 => 엘리베이터 가장 안쪽 => 내릴 때는 누가 먼저? 엘리베이터를 가장 늦게 탑승



